<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Finder ‚Äì Generate Shades & Palettes</title>
  <meta name="description" content="Enter HEX or RGB code to generate similar shades, harmonies, and color palettes. Export results in CSS, JSON, or HEX.">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- ...existing code for color finder tool copied from PickColors.html... -->
       <!-- üîç Color Finder by Code Page -->
<div id="color-finder-page" class="page">

    <!-- Tool Container -->
    <div class="tool-container">
        <div class="tool-header">
            <h2>üîç Color Finder by Code</h2>
            <p>Enter a HEX or RGB(A) color code and discover similar shades, palettes, and harmonies for design
                use.</p>
        </div>

        <div class="tool-content">
            <!-- Input Section -->
            <div class="input-section">
                <h3>Color Input</h3>
                <div class="color-input-group">
                    <label>Pick a Color:</label>
                    <input type="color" id="cfPicker" class="cf-picker" value="#4A90E2">
                </div>
                <div class="color-input-group">
                    <label>Enter HEX or RGB(A):</label>
                    <input type="text" id="cfColorInput" placeholder="#4A90E2 or rgb(74,144,226)">
                </div>
                <div class="color-input-group">
                    <label>Number of Shades:</label>
                    <input type="number" id="cfCount" value="12" min="4" max="50">
                </div>
                <button class="btn" id="cfGenerate">Generate Shades</button>
            </div>

            <!-- Output Section -->
            <div class="output-section">
                <h3>Original Color</h3>
                <div class="color-display" id="cfOriginalSwatch">#4A90E2</div>
                <div class="color-info">
                    <div><strong>HEX:</strong> <span id="cfOriginalHex">#4A90E2</span></div>
                    <div><strong>RGB:</strong> <span id="cfOriginalRgb">rgb(74,144,226)</span></div>
                </div>

                <h3>Similar Shades</h3>
                <div id="cfShadesGrid" class="palette-grid"></div>

                <h3>Saved Palette</h3>
                <div id="cfPalette" class="palette-grid"></div>
                <div class="palette-actions">
                    <button class="btn outline" id="cfExportJSON">Export JSON</button>
                    <button class="btn outline" id="cfExportCSS">Export CSS Variables</button>
                    <button class="btn outline" id="cfCopyList">Copy HEX List</button>
                    <button class="btn danger" id="cfClearPalette">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚úÖ SEO Article Section -->
    <div class="article-box" style="margin:20px 0; padding:20px; border:1px solid #eee; border-radius:18px;">
        <h2>üîç Color Finder by Code ‚Äì Generate Shades & Palettes</h2>
        <p>
            The <strong>Color Finder by Code</strong> is a powerful tool that takes a <strong>HEX or RGB(A)</strong> 
            color value and generates <strong>similar shades, palettes, and harmonies</strong>. It‚Äôs an essential tool 
            for web designers, UI developers, and digital artists.
        </p>

        <h3>üîë Key Features</h3>
        <ul>
            <li>Generate multiple shades from a single color</li>
            <li>Supports HEX and RGB(A) input formats</li>
            <li>Preview palettes in real time</li>
            <li>Export palettes as JSON or CSS variables</li>
            <li>Save and copy HEX lists for quick use</li>
        </ul>

        <h3>‚úÖ Why Use It?</h3>
        <p>
            Picking the right shades is essential for <strong>UI/UX design</strong>. 
            This tool makes it easy to create harmonious palettes from a single color, 
            helping you speed up your workflow and maintain design consistency.
        </p>

        <p>üëâ Try the <strong>Color Finder by Code</strong> today and generate beautiful palettes in seconds!</p>
    </div>
        </div>
    </div>
</div> <!-- End of color-finder-page -->

    <script>

 /*=================================================== üîç Color Finder by Code ====================================*/
        (function () {
            // Helpers
            function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
            function hexToRgb(hex) {
                if (!hex) return null;
                hex = hex.trim().replace('#', '');
                if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
                if (hex.length !== 6) return null;
                const n = parseInt(hex, 16);
                return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
            }
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
            }
            function parseRgbString(s) {
                const m = s.match(/rgba?\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)/i);
                if (!m) return null;
                return { r: Math.round(+m[1]), g: Math.round(+m[2]), b: Math.round(+m[3]) };
            }

            // HSL conversions
            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min;
                let h = 0, s = 0, l = (max + min) / 2;
                if (d !== 0) {
                    s = d / (1 - Math.abs(2 * l - 1));
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                        case g: h = ((b - r) / d + 2); break;
                        case b: h = ((r - g) / d + 4); break;
                    }
                    h *= 60;
                }
                return { h: Math.round(h), s: Math.round(s * 100), l: Math.round(l * 100) };
            }
            function hslToRgb(h, s, l) {
                s /= 100; l /= 100; h /= 360;
                if (s === 0) { const v = Math.round(l * 255); return { r: v, g: v, b: v }; }
                function hue2rgb(p, q, t) {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                const r = Math.round(hue2rgb(p, q, h + 1 / 3) * 255);
                const g = Math.round(hue2rgb(p, q, h) * 255);
                const b = Math.round(hue2rgb(p, q, h - 1 / 3) * 255);
                return { r, g, b };
            }

            function distanceRgb(a, b) {
                return Math.sqrt((a.r - b.r) ** 2 + (a.g - b.g) ** 2 + (a.b - b.b) ** 2);
            }

            // UI helpers
            const $ = id => document.getElementById(id);
            // Use global showToast function for all tools
            function copyText(t) {
                navigator.clipboard.writeText(t).then(() => showToast('Copied: ' + t), () => showToast('Copy failed'));
            }

            // Generate shades
            function generateShadesFromRgb(rgb, count, mode) {
                const baseHsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                const shades = [];
                for (let i = 0; i < count; i++) {
                    const t = (i / (count - 1)) * 2 - 1; // -1 ‚Üí 1
                    const hueShift = (Math.sign(t) * Math.pow(Math.abs(t), 1.1)) * 8;
                    let satAdj = (-t * 18);
                    let lightAdj = (-t * 22);
                    if (mode === 'lightness-only') satAdj = 0;
                    const h = (baseHsl.h + hueShift + 360) % 360;
                    const s = clamp(baseHsl.s + satAdj, 6, 98);
                    const l = clamp(baseHsl.l + lightAdj, 4, 96);
                    const rgbNew = hslToRgb(h, s, l);
                    const hex = rgbToHex(rgbNew.r, rgbNew.g, rgbNew.b);
                    const dist = distanceRgb(rgb, rgbNew);
                    shades.push({ hex, rgb: rgbNew, hsl: { h, s, l }, dist });
                }
                return shades.sort((a, b) => a.dist - b.dist);
            }

            // DOM elements
            const input = $('cfColorInput');
            const picker = $('cfPicker');
            const generateBtn = $('cfGenerate');
            const countEl = $('cfCount');
            const modeEl = $('cfMode');
            const origSwatch = $('cfOriginalSwatch');
            const origHex = $('cfOriginalHex');
            const origRgb = $('cfOriginalRgb');
            const grid = $('cfShadesGrid');
            const paletteRow = $('cfPalette');

            // palette store
            let finderPalette = [];

            // render functions
            function renderOriginal(rgb) {
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                origSwatch.style.background = hex;
                origSwatch.textContent = hex;
                origHex.textContent = 'HEX: ' + hex;
                origRgb.textContent = `RGB: rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            }

            function renderShades(shades) {
                grid.innerHTML = '';
                shades.forEach(s => {
                    const card = document.createElement('div');
                    card.className = 'shade-card';
                    card.setAttribute("data-color", s.hex);

                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'shade-color';
                    colorDiv.style.background = s.hex;

                    const info = document.createElement('div');
                    info.className = 'shade-info';
                    info.innerHTML = `<strong>${s.hex}</strong><div>rgb(${s.rgb.r}, ${s.rgb.g}, ${s.rgb.b})</div>`;

                    card.appendChild(colorDiv);
                    card.appendChild(info);

                    card.addEventListener('click', () => copyText(s.hex));
                    card.addEventListener('dblclick', () => addToPalette(s.hex));

                    grid.appendChild(card);
                });
            }

            function renderPalette() {
                paletteRow.innerHTML = '';
                palette.forEach(hex => {
                    const el = document.createElement('div');
                    el.className = 'palette-color';
                    el.style.background = hex;
                    el.title = hex;
                    el.addEventListener('click', () => copyText(hex));
                    el.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        palette = palette.filter(h => h !== hex);
                        renderPalette();
                    });
                    paletteRow.appendChild(el);
                });
            }

            function addToPalette(hex) {
                if (!palette.includes(hex)) palette.push(hex);
                renderPalette();
                showToast('Added to palette: ' + hex);
            }

            // generate handler
            function handleGenerate() {
                const raw = input.value.trim() || picker.value;
                let rgb = null;
                if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(raw)) rgb = hexToRgb(raw);
                else rgb = parseRgbString(raw);
                if (!rgb) { showToast('Invalid color. Use #HEX or rgb(...)'); return; }
                renderOriginal(rgb);
                const count = Math.max(4, Math.min(48, parseInt(countEl.value) || 12));
                const mode = modeEl ? modeEl.value : 'default';
                const shades = generateShadesFromRgb(rgb, count, mode);
                renderShades(shades);
            }

            // ‚úÖ Export JSON
            function exportJSON() {
                const shades = document.querySelectorAll(".shade-card");
                let data = [];
                shades.forEach(shade => {
                    const color = shade.getAttribute("data-color");
                    if (color) data.push(color);
                });
                if (data.length === 0) return showToast("‚ö†Ô∏è No colors to export.");
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "colors.json";
                a.click();
                URL.revokeObjectURL(url);
                showToast("‚úÖ JSON Exported");
            }

            // ‚úÖ Export CSS Variables
            function exportCSSVars() {
                const shades = document.querySelectorAll(".shade-card");
                let cssVars = ":root {\n";
                shades.forEach((shade, i) => {
                    const color = shade.getAttribute("data-color");
                    if (color) cssVars += `  --color-${i + 1}: ${color};\n`;
                });
                cssVars += "}";
                if (cssVars === ":root {\n}") return showToast("‚ö†Ô∏è No colors to export.");
                const blob = new Blob([cssVars], { type: "text/css" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "colors.css";
                a.click();
                URL.revokeObjectURL(url);
                showToast("‚úÖ CSS Exported");
            }

            // ‚úÖ Copy HEX List
            function copyHEXList() {
                const shades = document.querySelectorAll(".shade-card");
                let hexList = [];
                shades.forEach(shade => {
                    const color = shade.getAttribute("data-color");
                    if (color) hexList.push(color);
                });
                if (hexList.length === 0) return showToast("‚ö†Ô∏è No colors to copy.");
                navigator.clipboard.writeText(hexList.join(", ")).then(() => {
                    showToast("üìã HEX list copied!");
                });
            }

            // ‚úÖ Clear Results
            function clearResults() {
                origSwatch.style.background = "transparent";
                origSwatch.textContent = "";
                origHex.textContent = "";
                origRgb.textContent = "";
                grid.innerHTML = "";
                paletteRow.innerHTML = "";
                palette = [];
                showToast("üßπ Cleared");
            }
            /* ---------- Toast + Copy helpers (reusable) ---------- */
            function showToast(message) {
                let toast = document.getElementById("cfToast");
                if (!toast) {
                    toast = document.createElement("div");
                    toast.id = "cfToast";
                    toast.className = "toast";
                    document.body.appendChild(toast);
                }
                toast.textContent = message;
                toast.classList.add("show");
                // remove show after timeout (match your CSS)
                setTimeout(() => toast.classList.remove("show"), 1800);
            }

            function copyToClipboard(text) {
                // Use navigator.clipboard when available for silent copy + toast
                if (navigator.clipboard && window.isSecureContext) {
                    return navigator.clipboard.writeText(text)
                        .then(() => { showToast("Copied to clipboard!"); })
                        .catch(() => { showToast("Copy failed"); });
                }
                // Fallback: create textarea and execCommand
                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.left = "-9999px";
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand("copy");
                    document.body.removeChild(ta);
                    showToast("Copied to clipboard!");
                    return Promise.resolve();
                } catch (e) {
                    showToast("Copy failed");
                    return Promise.reject(e);
                }
            }

            /* ---------- Export JSON (downloads colors from shade cards) ---------- */
            function exportJSON() {
                const shades = document.querySelectorAll(".shade-card");
                const data = [];
                shades.forEach(shade => {
                    const color = shade.getAttribute("data-color") || shade.dataset.color;
                    if (color) data.push(color);
                });
                if (data.length === 0) {
                    showToast("‚ö†Ô∏è No colors to export.");
                    return;
                }
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "colors.json";
                document.body.appendChild(a);
                a.click();
                a.remove();
                // revoke after a tick
                setTimeout(() => URL.revokeObjectURL(url), 500);
                showToast("‚úÖ JSON exported");
            }

            /* ---------- Export CSS Variables (downloads :root vars) ---------- */
            function exportCSSVars() {
                const shades = document.querySelectorAll(".shade-card");
                const vars = [];
                shades.forEach((shade, i) => {
                    const color = shade.getAttribute("data-color") || shade.dataset.color;
                    if (color) vars.push({ index: i + 1, color });
                });
                if (vars.length === 0) {
                    showToast("‚ö†Ô∏è No colors to export.");
                    return;
                }
                let css = ":root {\n";
                vars.forEach(v => {
                    css += `  --color-${v.index}: ${v.color};\n`;
                });
                css += "}\n";
                const blob = new Blob([css], { type: "text/css" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "colors.css";
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 500);
                showToast("‚úÖ CSS variables exported");
            }

            /* ---------- Copy HEX List (copies comma/newline separated list) ---------- */
            function copyHEXList() {
                const shades = document.querySelectorAll(".shade-card");
                const hexList = [];
                shades.forEach(shade => {
                    const color = shade.getAttribute("data-color") || shade.dataset.color;
                    if (color) hexList.push(color);
                });
                if (hexList.length === 0) {
                    showToast("‚ö†Ô∏è No colors to copy.");
                    return;
                }
                // prefer newline-separated (easier to paste), use join(", ") if you prefer commas
                const text = hexList.join("\n");
                copyToClipboard(text).then(() => {
                    /* toast shown by copyToClipboard */
                }).catch(() => {
                    showToast("Copy failed");
                });
            }

            /* ---------- Clear Results (clears original, shades grid and palette) ---------- */
            function clearResults() {
                // original swatch elements (IDs used earlier)
                const origSwatch = document.getElementById("cfOriginalSwatch") || document.getElementById("original-color");
                const origHex = document.getElementById("cfOriginalHex");
                const origRgb = document.getElementById("cfOriginalRgb");

                if (origSwatch) {
                    origSwatch.style.background = "transparent";
                    origSwatch.textContent = "";
                }
                if (origHex) origHex.textContent = "";
                if (origRgb) origRgb.textContent = "";

                // clear shades grid
                const grid = document.getElementById("cfShadesGrid") || document.getElementById("shades");
                if (grid) grid.innerHTML = "";

                // clear palette container
                const palette = document.getElementById("cfPalette") || document.getElementById("palette") || document.getElementById("cfPaletteRow");
                if (palette) palette.innerHTML = "";

                // reset internal palette array if you use one
                if (typeof window.palette !== "undefined") window.palette = [];
                showToast("üßπ Cleared");
            }


            // wire events
            document.addEventListener('DOMContentLoaded', () => {
                input.value = picker.value;
                handleGenerate();

                picker.addEventListener('input', e => {
                    input.value = e.target.value;
                    handleGenerate();
                });
                generateBtn.addEventListener('click', handleGenerate);

                $('cfExportJSON').addEventListener('click', exportJSON);
                $('cfExportCSS').addEventListener('click', exportCSSVars);
                $('cfCopyList').addEventListener('click', copyHEXList);
                $('cfClearPalette').addEventListener('click', clearResults);
            });
        })();

    </script>
        <script src="PickColors.js"></script>

</body>
</html>
